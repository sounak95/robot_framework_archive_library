<?xml version="1.0" encoding="UTF-8"?>
<keywordspec generated="20190826 17:25:23" type="library" name="SSHLibrary" format="ROBOT">
<version>2.1.2</version>
<scope>global</scope>
<namedargs>yes</namedargs>
<doc>Robot Framework test library for SSH and SFTP.

The library has the following main usages:
- Executing commands on the remote machine, either with blocking or
  non-blocking behaviour (see `Execute Command` and `Start Command`,
  respectively).
- Writing and reading in an interactive shell (e.g. `Read` and `Write`).
- Transferring files and directories over SFTP (e.g. `Get File` and
  `Put Directory`).
- Ensuring that files or directories exist on the remote machine
  (e.g. `File Should Exist` and `Directory Should Not Exist`).

This library works both with Python and Jython, but uses different
tools internally depending on the interpreter. See
[http://code.google.com/p/robotframework-sshlibrary/wiki/InstallationInstructions|installation instructions]
for more details about the dependencies. IronPython is unfortunately not
supported.

== Table of contents ==

- `Connections and login`
- `Configuration`
- `Executing commands`
- `Interactive shells`
- `Pattern matching`
- `Example`
- `Importing`
- `Shortcuts`
- `Keywords`

= Connections and login =

The library supports multiple connections to different hosts.
New connections are opened with `Open Connection`.

Logging into the host is done either with username and password
(`Login`) or with public/private key pair (`Login With Public key`).

Only one connection can be active at a time. This means that most of the
keywords only affect the active connection. Active connection can be
changed with `Switch Connection`.

= Configuration =

Default settings for all the upcoming connections can be configured on
`library importing` or later with `Set Default Configuration`.
All the settings are listed further below.

Using `Set Default Configuration` does not affect the already open
connections. Settings of the current connection can be configured
with `Set Client Configuration`. Settings of another, non-active connection,
can be configured by first using `Switch Connection` and then
`Set Client Configuration`.

Most of the defaults can be overridden per connection by defining them
as arguments to `Open Connection`. Otherwise the defaults are used.

== Configurable per connection ==

=== Default prompt ===

Argument `prompt` defines the character sequence used by `Read Until Prompt`
and must be set before that keyword can be used.

If you know the prompt on the remote machine, it is recommended to set it
to ease reading output from the server after using `Write`. In addition to
that, `Login` and `Login With Public Key` can read the server output more
efficiently when the prompt is set.

=== Default encoding ===

Argument `encoding` defines the
[http://docs.python.org/2/library/codecs.html#standard-encodings|
character encoding] of input and output sequences.
Starting from SSHLibrary 2.0, the default value is `UTF-8`.

=== Default path separator ===

Argument `path_separator` must be set to the one known by the operating
system and the SSH server on the remote machine. The path separator is
used by keywords `Get File`, `Put File`, `Get Directory` and
`Put Directory` for joining paths correctly on the remote host.

The default path separator is forward slash (`/`) which works on
Unix-like machines. On Windows the path separator to use depends on
the SSH server. Some servers use forward slash and others backslash,
and users need to configure the `path_separator` accordingly. Notice
that using a backslash in Robot Framework test data requires doubling
it like `\\`.

Configuring the library and connection specific path separator is a new
feature in SSHLibrary 2.0. Prior to it `Get File` and `Put File` had
their own `path_separator` arguments. These keyword specific arguments
were deprecated in 2.0 and will be removed in the future.

=== Default timeout ===

Argument `timeout` is used by `Read Until` variants. The default value is
`3 seconds`.

Value must be in Robot Framework's time format, e.g. `3`, `4.5s`, `1 minute`
and `2 min 3 s` are all accepted. See section `Time Format` in the
Robot Framework User Guide for details.

=== Default newline ===

Argument `newline` is the line break sequence used by `Write` keyword and
must be set according to the operating system on the remote machine.
The default value is `LF` (same as `\n`) which is used on Unix-like
operating systems. With Windows remote machines, you need to set this to
`CRLF` (`\r\n`).

=== Default terminal settings ===

Argument `term_type` defines the virtual terminal type, and arguments
`width` and `height` can be used to control its  virtual size.

== Not configurable per connection ==

=== Default loglevel ===

Argument `loglevel` sets the log level used to log the output read by
`Read`, `Read Until`, `Read Until Prompt`, `Read Until Regexp`, `Write`,
`Write Until Expected Output`, `Login` and `Login With Public Key`.
The default level is `INFO`.

`loglevel` is not configurable per connection but can be overridden by
passing it as an argument to the most of the mentioned keywords.
Possible argument values are `TRACE`, `DEBUG`, `INFO` and `WARN`.

= Executing commands =

For executing commands on the remote machine, there are two possibilities:

- `Execute Command` and `Start Command`.
   The command is executed in a new shell on the remote machine,
   which means that possible changes to the environment
   (e.g. changing working directory, setting environment variables, etc.)
   are not visible to the subsequent keywords.

- `Write`, `Write Bare`, `Write Until Expected Output`, `Read`,
  `Read Until`, `Read Until Prompt` and `Read Until Regexp`.
   These keywords operate in an interactive shell, which means that changes
   to the environment are visible to the subsequent keywords.

= Interactive shells =

`Write`, `Write Bare`, `Write Until Expected Output`, `Read`,
`Read Until`, `Read Until Prompt` and `Read Until Regexp` can be used
to interact with the server within the same shell.

== Consumed output ==

All of these keywords, except `Write Bare`, consume the read or the written
text from the server output before returning. In practice this means that
the text is removed from the server output, i.e. subsequent calls to
`Read` keywords do not return text that was already read. This is
illustrated by the example below.

| `Write`              | echo hello   |       | # consumes written `echo hello`                  |
| ${stdout}=           | `Read Until` | hello | # consumes read `hello` and everything before it |
| `Should Contain`     | ${stdout}    | hello |
| ${stdout}=           | `Read`       |       | # consumes everything available                  |
| `Should Not Contain` | ${stdout}    | hello | # `hello` was already consumed earlier           |

The consumed text is logged by the keywords and their argument `loglevel`
can be used to override [#Default loglevel|the default log level].

`Login` and `Login With Public Key` consume everything on the server output
or if [#Default prompt|the prompt is set], everything until the prompt.

== Reading ==

`Read`, `Read Until`, `Read Until Prompt` and `Read Until Regexp` can be
used to read from the server. The read text is also consumed from
the server output.

`Read` reads everything available on the server output, thus clearing it.

`Read Until` variants read output up until and *including* `expected` text.
These keywords will fail if [#Default timeout|the timeout] expires before
`expected` is found.

== Writing ==

`Write` and `Write Until Expected Output` consume the written text
from the server output while `Write Bare` does not.

These keywords do not return any output triggered by the written text.
To get the output, one of the `Read` keywords must be explicitly used.

= Pattern matching =

Some keywords allow their arguments to be specified as _glob patterns_
where:
| *        | matches anything, even an empty string |
| ?        | matches any single character |
| [chars]  | matches any character inside square brackets (e.g. `[abc]` matches either `a`, `b` or `c`) |
| [!chars] | matches any character not inside square brackets |

Pattern matching is case-sensitive regardless the local or remote
operating system. Matching is implemented using Python's
[http://docs.python.org/library/fnmatch.html|fnmatch module].

= Example =
| ***** Settings *****
| Documentation          This example demonstrates executing commands on a remote machine
| ...                    and getting their output and the return code.
| ...
| ...                    Notice how connections are handled as part of the suite setup and
| ...                    teardown. This saves some time when executing several test cases.
|
| Library                `SSHLibrary`
| Suite Setup            `Open Connection And Log In`
| Suite Teardown         `Close All Connections`
|
| ***** Variables *****
| ${HOST}                localhost
| ${USERNAME}            test
| ${PASSWORD}            test
|
| ***** Test Cases *****
| Execute Command And Verify Output
|     [Documentation]    `Execute Command` can be used to ran commands on the remote machine.
|     ...                The keyword returns the standard output by default.
|     ${output}=    `Execute Command`    echo Hello SSHLibrary!
|     `Should Be Equal`    ${output}    Hello SSHLibrary!
|
| Execute Command And Verify Return Code
|     [Documentation]    Often getting the return code of the command is enough.
|     ...                This behaviour can be adjusted as `Execute Command` arguments.
|     ${rc}=    `Execute Command`    echo Success guaranteed.    return_stdout=False    return_rc=True
|     `Should Be Equal`    ${rc}    ${0}
|
| Executing Commands In An Interactive Session
|     [Documentation]    `Execute Command` always executes the command in a new shell.
|     ...                This means that changes to the environment are not persisted
|     ...                between subsequent `Execute Command` keyword calls.
|     ...                `Write` and `Read Until` variants can be used to operate in the same shell.
|     `Write`    cd ..
|     `Write`    echo Hello from the parent directory!
|     ${output}=    `Read Until`    directory!
|     `Should End With`     ${output}    Hello from the parent directory!
|
| ***** Keywords *****
| Open Connection And Log In
|    `Open Connection`    ${HOST}
|    `Login`    ${USERNAME}    ${PASSWORD}

Save the content as file `executing_command.txt` and run:

| pybot executing_commands.txt

You may want to override the variables from commandline to try this out on
your remote machine:

| pybot -v HOST:my.server.com -v USERNAME:johndoe -v PASSWORD:secretpasswd executing_commands.txt</doc>
<init>
<arguments>
<arg>timeout=3 seconds</arg>
<arg>newline=LF</arg>
<arg>prompt=None</arg>
<arg>loglevel=INFO</arg>
<arg>term_type=vt100</arg>
<arg>width=80</arg>
<arg>height=24</arg>
<arg>path_separator=/</arg>
<arg>encoding=UTF-8</arg>
</arguments>
<doc>SSHLibrary allows some import time `configuration`.

If the library is imported without any arguments, the library
defaults are used:
| Library | SSHLibrary |

Only arguments that are given are changed. In this example,
[#Default timeout|the timeout] is changed to `10 seconds` but
other settings are left to the library defaults:
| Library | SSHLibrary | 10 seconds |

[#Default prompt|Prompt] does not have a default value and
must be explicitly set to use `Read Until Prompt`.
In this example, the prompt is set to `$`:
| Library | SSHLibrary | prompt=$ |

Multiple settings are possible. In this example, the library is brought
into use with [#Default newline|newline] and [#Default path separator|
path_separator] known by Windows:
| Library | SSHLibrary | newline=CRLF | path_separator=\\ |

Arguments [#Default terminal settings|`term_type`],
[#Default terminal settings|`width`],
[#Default terminal settings|`height`],
[#Default path separator|`path separator`] and
[#Default encoding|`encoding`]
were added in SSHLibrary 2.0.</doc>
<tags>
</tags>
</init>
<kw name="Close All Connections">
<arguments>
</arguments>
<doc>Closes all open connections.

This keyword is ought to be used either in test or suite teardown to
make sure all the connections are closed before the test execution
finishes.

After this keyword, the connection indices returned by `Open Connection`
are reset and start from `1`.

Example:
| Open Connection | my.server.com         |
| Open Connection | build.local.net       |
| # Do something with the connections     |
| [Teardown]      | Close all connections |</doc>
<tags>
</tags>
</kw>
<kw name="Close Connection">
<arguments>
</arguments>
<doc>Closes the current connection.

No other connection is made active by this keyword. Manually use
`Switch Connection` to switch to another connection.

Example:
| Open Connection  | my.server.com  |
| Login            | johndoe        | secretpasswd |
| Get File         | results.txt    | /tmp         |
| Close Connection |
| # Do something with /tmp/results.txt             |</doc>
<tags>
</tags>
</kw>
<kw name="Directory Should Exist">
<arguments>
<arg>path</arg>
</arguments>
<doc>Fails if the given `path` does not point to an existing directory.

Example:
| Directory Should Exist | /usr/share/man |

Note that symlinks are followed:
| Directory Should Exist | /usr/local/man | # Points to /usr/share/man/ |

New in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Directory Should Not Exist">
<arguments>
<arg>path</arg>
</arguments>
<doc>Fails if the given `path` points to an existing directory.

Example:
| Directory Should Not Exist | /non/existing |

Note that this keyword follows symlinks. Thus the example fails if
`/non/existing` is a link that points to an existing directory.

New in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Enable Ssh Logging">
<arguments>
<arg>logfile</arg>
</arguments>
<doc>Enables logging of SSH protocol output to given `logfile`.

All the existing and upcoming connections are logged onwards from
the moment the keyword was called.

`logfile` is path to a file that is writable by the current local user.
If the file already exists, it will be overwritten.

*Note:* This keyword only works with Python, i.e. when executing tests
with `pybot`.

Example:
| Open Connection    | my.server.com   | # Not logged |
| Enable SSH Logging | myserver.log    |
| Login              | johndoe         | secretpasswd |
| Open Connection    | build.local.net | # Logged     |
| # Do something with the connections  |
| # Check myserver.log for detailed debug information |</doc>
<tags>
</tags>
</kw>
<kw name="Execute Command">
<arguments>
<arg>command</arg>
<arg>return_stdout=True</arg>
<arg>return_stderr=False</arg>
<arg>return_rc=False</arg>
</arguments>
<doc>Executes `command` on the remote machine and returns its outputs.

This keyword executes the `command` and returns after the execution
has been finished. Use `Start Command` if the command should be
started on the background.

By default, only the standard output is returned:
| ${stdout}=     | Execute Command | echo 'Hello John!' |
| Should Contain | ${stdout}       | Hello John!        |

Arguments `return_stdout`, `return_stderr` and `return_rc` are used
to specify, what is returned by this keyword.
If several arguments evaluate to true, multiple values are returned.
Non-empty strings, except `false` and `False`, evaluate to true.

If errors are needed as well, set the respective argument value to true:
| ${stdout}       | ${stderr}= | Execute Command | echo 'Hello John!' | return_stderr=True |
| Should Be Empty | ${stderr}  |

Often checking the return code is enough:
| ${rc}=                      | Execute Command | echo 'Hello John!' | return_stdout=False | return_rc=True |
| Should Be Equal As Integers | ${rc}           | 0                  | # succeeded         |

The `command` is always executed in a new shell. Thus possible changes
to the environment (e.g. changing working directory) are not visible
to the later keywords:
| ${pwd}=         | Execute Command | pwd           |
| Should Be Equal | ${pwd}          | /home/johndoe |
| Execute Command | cd /tmp         |
| ${pwd}=         | Execute Command | pwd           |
| Should Be Equal | ${pwd}          | /home/johndoe |

`Write` and `Read` can be used for
[#Interactive shells|running multiple commands in the same shell].

This keyword logs the executed command and its exit status with
log level `INFO`.</doc>
<tags>
</tags>
</kw>
<kw name="File Should Exist">
<arguments>
<arg>path</arg>
</arguments>
<doc>Fails if the given `path` does NOT point to an existing file.

Example:
| File Should Exist | /boot/initrd.img |

Note that symlinks are followed:
| File Should Exist | /initrd.img | # Points to boot/initrd.img |

New in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="File Should Not Exist">
<arguments>
<arg>path</arg>
</arguments>
<doc>Fails if the given `path` points to an existing file.

Example:
| File Should Not Exist | /non/existing |

Note that this keyword follows symlinks. Thus the example fails if
`/non/existing` is a link that points an existing file.

New in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Get Connection">
<arguments>
<arg>index_or_alias=None</arg>
<arg>index=False</arg>
<arg>host=False</arg>
<arg>alias=False</arg>
<arg>port=False</arg>
<arg>timeout=False</arg>
<arg>newline=False</arg>
<arg>prompt=False</arg>
<arg>term_type=False</arg>
<arg>width=False</arg>
<arg>height=False</arg>
<arg>encoding=False</arg>
</arguments>
<doc>Return information about the connection.

Connection is not changed by this keyword, use `Switch Connection` to
change the active connection.

If `index_or_alias` is not given, the information of the current
connection is returned.

This keyword returns an object that has the following attributes:
| = Name =       | = Type = | = Explanation = |
| index          | integer  | Number of the connection. Numbering starts from `1`. |
| host           | string   | Destination hostname. |
| alias          | string   | An optional alias given when creating the connection.  |
| port           | integer  | Destination port. |
| timeout        | string   | [#Default timeout|Timeout] length in textual representation. |
| newline        | string   | [#Default newline|The line break sequence] used by `Write` keyword. |
| prompt         | string   | [#Default prompt|Prompt character sequence] for `Read Until Prompt`. |
| term_type      | string   | Type of the [#Default terminal settings|virtual terminal]. |
| width          | integer  | Width of the [#Default terminal settings|virtual terminal]. |
| height         | integer  | Height of the [#Default terminal settings|virtual terminal]. |
| path_separator | string   | [#Default path separator|The path separator] used on the remote host. |
| encoding       | string   | [#Default encoding|The encoding] used for inputs and outputs. |

If there is no connection, an object having `index` and `host` as `None`
is returned, rest of its attributes having their values as configuration
defaults.

If you want the information for all the open connections, use
`Get Connections`.

Getting connection information of the current connection:
| Open Connection | far.server.com        |
| Open Connection | near.server.com       | prompt=&gt;&gt;       | # Current connection |
| ${nearhost}=    | Get Connection        |                 |
| Should Be Equal | ${nearhost.host}      | near.server.com |
| Should Be Equal | ${nearhost.index}     | 2               |
| Should Be Equal | ${nearhost.prompt}    | &gt;&gt;              |
| Should Be Equal | ${nearhost.term_type} | vt100           | # From defaults      |

Getting connection information using an index:
| Open Connection | far.server.com   |
| Open Connection | near.server.com  | # Current connection |
| ${farhost}=     | Get Connection   | 1                    |
| Should Be Equal | ${farhost.host}  | far.server.com       |

Getting connection information using an alias:
| Open Connection | far.server.com   | alias=far            |
| Open Connection | near.server.com  | # Current connection |
| ${farhost}=     | Get Connection   | far                  |
| Should Be Equal | ${farhost.host}  | far.server.com       |
| Should Be Equal | ${farhost.alias} | far                  |

This keyword can also return plain connection attributes instead of
the whole connection object. This can be adjusted using the boolean
arguments `index`, `host`, `alias`, and so on, that correspond to
the attribute names of the object. If such arguments are given, and
they evaluate to true (e.g. any non-empty string except `false` or
`False`), only the respective connection attributes are returned.
Note that attributes are always returned in the same order arguments
are specified in the signature.

| Open Connection | my.server.com  | alias=example  |
| ${host}=        | Get Connection | host=True      |
| Should Be Equal | ${host}        | my.server.com  |
| ${host}         | ${alias}=      | Get Connection | host=yes | alias=please |
| Should Be Equal | ${host}        | my.server.com  |
| Should Be Equal | ${alias}       | example        |

Getting only certain attributes is especially useful when using this
library via the Remote library interface. This interface does not
support returning custom objects, but individual attributes can be
returned just fine.

This keyword logs the connection information with log level `INFO`.

New in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Get Connections">
<arguments>
</arguments>
<doc>Return information about all the open connections.

This keyword returns a list of objects that are identical to the ones
returned by `Get Connection`.

Example:
| Open Connection             | near.server.com     | timeout=10s     |
| Open Connection             | far.server.com      | timeout=5s      |
| ${nearhost}                 | ${farhost}=         | Get Connections |
| Should Be Equal             | ${nearhost.host}    | near.server.com |
| Should Be Equal As Integers | ${nearhost.timeout} | 10              |
| Should Be Equal As Integers | ${farhost.port}     | 22              |
| Should Be Equal As Integers | ${farhost.timeout}  | 5               |

This keyword logs the information of connections with log level `INFO`.</doc>
<tags>
</tags>
</kw>
<kw name="Get Directory">
<arguments>
<arg>source</arg>
<arg>destination=.</arg>
<arg>recursive=False</arg>
</arguments>
<doc>Downloads a directory, including its content, from the remote machine to the local machine.

`source` is a path on the remote machine. Both absolute paths and
paths relative to the current working directory are supported.

`destination` is the target path on the local machine.  Both absolute
paths and paths relative to the current working directory are supported.

`recursive` specifies, whether to recursively download all
subdirectories inside `source`. Subdirectories are downloaded if
the argument value evaluates to true.

Examples:
| Get Directory | /var/logs      | /tmp                |
| Get Directory | /var/logs      | /tmp/non/existing   |
| Get Directory | /var/logs      |
| Get Directory | /var/logs      | recursive=True      |

The local `destination` is created as following:

1. If `destination` is an existing path on the local machine,
   `source` directory is downloaded into it.

2. If `destination` does not exist on the local machine, it is created
   and the content of `source` directory is downloaded into it.

3. If `destination` is not given, `source` directory is downloaded into
   the current working directory on the local machine. This is typically
   the directory where the test execution was started and thus
   accessible using built-in `${EXECDIR}` variable.

New in SSHLibrary 2.0.

See also `Get File`.</doc>
<tags>
</tags>
</kw>
<kw name="Get File">
<arguments>
<arg>source</arg>
<arg>destination=.</arg>
</arguments>
<doc>Downloads file(s) from the remote machine to the local machine.

`source` is a path on the remote machine. Both absolute paths and
paths relative to the current working directory are supported.
If the source contains wildcards explained in `pattern matching`,
all files matching it are downloaded. In this case `destination`
must always be a directory.

`destination` is the target path on the local machine. Both absolute
paths and paths relative to the current working directory are supported.

`path_separator` was *removed* in SSHLibrary 2.1. Use [#Default
path separator|the library or the connection specific setting] instead.

Examples:
| Get File | /var/log/auth.log | /tmp/                      |
| Get File | /tmp/example.txt  | C:\\temp\\new_name.txt |
| Get File | /path/to/*.txt    |

The local `destination` is created using the rules explained below:

1. If the `destination` is an existing file, the `source` file is
   downloaded over it.

2. If the `destination` is an existing directory, the `source` file is
   downloaded into it. Possible file with the same name is overwritten.

3. If the `destination` does not exist and it ends with the path
   separator of the local operating system, it is considered a
   directory. The directory is then created and the `source` file is
   downloaded into it. Possible missing intermediate directories
   are also created.

4. If the `destination` does not exist and does not end with the local
   path separator, it is considered a file. The `source` file is
   downloaded and saved using that file name, and possible missing
   intermediate directories are also created.

5. If `destination` is not given, the current working directory on
   the local machine is used as the destination. This is typically
   the directory where the test execution was started and thus
   accessible using built-in `${EXECDIR}` variable.

Argument `path_separator` was deprecated in SSHLibrary 2.0.

See also `Get Directory`.</doc>
<tags>
</tags>
</kw>
<kw name="List Directories In Directory">
<arguments>
<arg>path</arg>
<arg>pattern=None</arg>
<arg>absolute=False</arg>
</arguments>
<doc>A wrapper for `List Directory` that returns only directories.

New in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="List Directory">
<arguments>
<arg>path</arg>
<arg>pattern=None</arg>
<arg>absolute=False</arg>
</arguments>
<doc>Returns and logs items in the remote `path`, optionally filtered with `pattern`.

`path` is a path on the remote machine. Both absolute paths and
paths relative to the current working directory are supported.
If `path` is a symlink, it is followed.

Item names are returned in case-sensitive alphabetical order,
e.g. ['A Name', 'Second', 'a lower case name', 'one more'].
Implicit directories `.` and `..` are not returned. The returned items
are automatically logged.

By default, the item names are returned relative to the given
remote path (e.g. `file.txt`). If you want them be returned in the
absolute format (e.g. `/home/johndoe/file.txt`), set the `absolute`
argument to any non-empty string.

If `pattern` is given, only items matching it are returned. The pattern
matching syntax is explained in `pattern matching`.

Examples (using also other `List Directory` variants):
| @{items}= | List Directory          | /home/johndoe |
| @{files}= | List Files In Directory | /tmp          | *.txt | absolute=True |

If you are only interested in directories or files,
use `List Files In Directory` or `List Directories In Directory`,
respectively.

New in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="List Files In Directory">
<arguments>
<arg>path</arg>
<arg>pattern=None</arg>
<arg>absolute=False</arg>
</arguments>
<doc>A wrapper for `List Directory` that returns only files.

New in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Login">
<arguments>
<arg>username</arg>
<arg>password</arg>
<arg>delay=0.5 seconds</arg>
</arguments>
<doc>Logs into the SSH server with the given `username` and `password`.

Connection must be opened before using this keyword.

This keyword reads, returns and logs the server output after logging in.
If the [#Default prompt|prompt is set], everything until the prompt
is read. Otherwise the output is read using the `Read` keyword with
the given `delay`. The output is logged using the [#Default loglevel|
default log level].

Example that logs in and returns the output:
| Open Connection | linux.server.com |
| ${output}=      | Login            | johndoe       | secretpasswd |
| Should Contain  | ${output}        | Last login at |

Example that logs in and returns everything until the prompt:
| Open Connection | linux.server.com | prompt=$         |
| ${output}=      | Login            | johndoe          | secretpasswd |
| Should Contain  | ${output}        | johndoe@linux:~$ |

Argument `delay` was added in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Login With Public Key">
<arguments>
<arg>username</arg>
<arg>keyfile</arg>
<arg>password=</arg>
<arg>delay=0.5 seconds</arg>
</arguments>
<doc>Logs into the SSH server using key-based authentication.

Connection must be opened before using this keyword.

`username` is the username on the remote machine.

`keyfile` is a path to a valid OpenSSH private key file on the local
filesystem.

`password` is used to unlock the `keyfile` if unlocking is required.

This keyword reads, returns and logs the server output after logging in.
If the [#Default prompt|prompt is set], everything until the prompt
is read. Otherwise the output is read using the `Read` keyword with
the given `delay`. The output is logged using the [#Default loglevel|
default log level].

Example that logs in using a private key and returns the output:
| Open Connection | linux.server.com      |
| ${output}=      | Login With Public Key | johndoe       | /home/johndoe/.ssh/id_rsa |
| Should Contain  | ${motd}               | Last login at |

With locked private keys, the keyring `password` is required:
| Open Connection       | linux.server.com |
| Login With Public Key | johndoe          | /home/johndoe/.ssh/id_dsa | keyringpasswd |

Argument `delay` was added in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Open Connection">
<arguments>
<arg>host</arg>
<arg>alias=None</arg>
<arg>port=22</arg>
<arg>timeout=None</arg>
<arg>newline=None</arg>
<arg>prompt=None</arg>
<arg>term_type=None</arg>
<arg>width=None</arg>
<arg>height=None</arg>
<arg>path_separator=None</arg>
<arg>encoding=None</arg>
</arguments>
<doc>Opens a new SSH connection to the given `host` and `port`.

The new connection is made active. Possible existing connections
are left open in the background.

Note that on Jython this keyword actually opens a connection and
will fail immediately on unreachable hosts. On Python the actual
connection attempt will not be done until `Login` is called.

This keyword returns the index of the new connection which can be used
later to switch back to it. Indices start from `1` and are reset
when `Close All Connections` is used.

Optional `alias` can be given for the connection and can be used for
switching between connections, similarly as the index.
See `Switch Connection` for more details.

Connection parameters, like [#Default timeout|`timeout`] and
[#Default newline|`newline`] are documented in `configuration`.
If they are not defined as arguments, [#Configuration|the library
defaults] are used for the connection.

All the arguments, except `host`, `alias` and `port`
can be later updated with `Set Client Configuration`.

Starting from SSHLibrary 1.1, a shell is automatically opened
by this keyword.

Port `22` is assumed by default:
| ${index}= | Open Connection | my.server.com |

Non-standard port may be given as an argument:
| ${index}= | Open Connection | 192.168.1.1 | port=23 |

Aliases are handy, if you need to switch back to the connection later:
| Open Connection   | my.server.com | alias=myserver |
| # Do something with my.server.com |
| Open Connection   | 192.168.1.1   |
| Switch Connection | myserver      |                | # Back to my.server.com |

Settings can be overridden per connection, otherwise the ones set on
`library importing` or with `Set Default Configuration` are used:
| Open Connection | 192.168.1.1   | timeout=1 hour    | newline=CRLF          |
| # Do something with the connection                  |
| Open Connection | my.server.com | # Default timeout | # Default line breaks |

[#Default terminal settings|The terminal settings] are also configurable
per connection:
| Open Connection | 192.168.1.1  | term_type=ansi | width=40 |

Arguments [#Default path separator|`path_separator`] and
[#Default encoding|`encoding`]
were added in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Put Directory">
<arguments>
<arg>source</arg>
<arg>destination=.</arg>
<arg>mode=0744</arg>
<arg>newline=</arg>
<arg>recursive=False</arg>
</arguments>
<doc>Uploads a directory, including its content, from the local machine to the remote machine.

`source` is the path on the local machine. Both absolute paths and
paths relative to the current working directory are supported.

`destination` is the target path on the remote machine. Both absolute
paths and paths relative to the current working directory are supported.

`mode` can be used to set the target file permission.
Numeric values are accepted. The default value is `0744` (-rwxr--r--).

`newline` can be used to force the line break characters that are
written to the remote files. Valid values are `LF` and `CRLF`.

`recursive` specifies, whether to recursively upload all
subdirectories inside `source`. Subdirectories are uploaded if the
argument value evaluates to true.

Examples:
| Put Directory | /var/logs | /tmp               |
| Put Directory | /var/logs | /tmp/non/existing  |
| Put Directory | /var/logs |
| Put Directory | /var/logs | recursive=True     |
| Put Directory | /var/logs | /home/groups/robot | mode=0770 |
| Put Directory | /var/logs | newline=CRLF       |

The remote `destination` is created as following:

1. If `destination` is an existing path on the remote machine,
   `source` directory is uploaded into it.

2. If `destination` does not exist on the remote machine, it is
   created and the content of `source` directory is uploaded into it.

3. If `destination` is not given, `source` directory is typically
   uploaded to user's home directory on the remote machine.

New in SSHLibrary 2.0.

See also `Put File`.</doc>
<tags>
</tags>
</kw>
<kw name="Put File">
<arguments>
<arg>source</arg>
<arg>destination=.</arg>
<arg>mode=0744</arg>
<arg>newline=</arg>
</arguments>
<doc>Uploads file(s) from the local machine to the remote machine.

`source` is the path on the local machine. Both absolute paths and
paths relative to the current working directory are supported.
If the source contains wildcards explained in `pattern matching`,
all files matching it are uploaded. In this case `destination`
must always be a directory.

`destination` is the target path on the remote machine. Both absolute
paths and paths relative to the current working directory are supported.

`mode` can be used to set the target file permission.
Numeric values are accepted. The default value is `0744` (-rwxr--r--).

`newline` can be used to force the line break characters that are
written to the remote files. Valid values are `LF` and `CRLF`.

`path_separator` was *removed* in SSHLibrary 2.1. Use [#Default
path separator|the library or the connection specific setting] instead.

Examples:
| Put File | /path/to/*.txt          |
| Put File | /path/to/*.txt          | /home/groups/robot | mode=0770 |
| Put File | /path/to/*.txt          | newline=CRLF       |

The remote `destination` is created as following:

1. If `destination` is an existing file, `source` file is uploaded
   over it.

2. If `destination` is an existing directory, `source` file is
   uploaded into it. Possible file with same name is overwritten.

3. If `destination` does not exist and it ends with [#Default path
   separator|the path separator], it is considered a directory.
   The directory is then created and `source` file uploaded into it.
   Possibly missing intermediate directories are also created.

4. If `destination` does not exist and it does not end with [#Default
   path separator|the path separator], it is considered a file.
   If the path to the file does not exist, it is created.

5. If `destination` is not given, the user's home directory
   on the remote machine is used as the destination.

See also `Put Directory`.</doc>
<tags>
</tags>
</kw>
<kw name="Read">
<arguments>
<arg>loglevel=None</arg>
<arg>delay=None</arg>
</arguments>
<doc>Consumes and returns everything available on the server output.

If `delay` is given, this keyword waits that amount of time and reads
output again. This wait-read cycle is repeated as long as further reads
return more output or the [#Default timeout|timeout] expires.
`delay` must be given in Robot Framework's time format (e.g. `5`,
`4.5s`, `3 minutes`, `2 min 3 sec`) that is explained in detail in
the User Guide.

This keyword is most useful for reading everything from
the server output, thus clearing it.

The read output is logged. `loglevel` can be used to override
the [#Default loglevel|default log level].

Example:
| Open Connection | my.server.com |
| Login           | johndoe       | secretpasswd                 |
| Write           | sudo su -     |                              |
| ${output}=      | Read          | delay=0.5s                   |
| Should Contain  | ${output}     | [sudo] password for johndoe: |
| Write           | secretpasswd  |                              |
| ${output}=      | Read          | loglevel=WARN | # Shown in the console due to loglevel |
| Should Contain  | ${output}     | root@                        |

See `interactive shells` for more information about writing and reading
in general.

Argument `delay` was added in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Read Command Output">
<arguments>
<arg>return_stdout=True</arg>
<arg>return_stderr=False</arg>
<arg>return_rc=False</arg>
</arguments>
<doc>Returns outputs of the most recent started command.

At least one command must have been started using `Start Command`
before this keyword can be used.

By default, only the standard output of the started command is returned:
| Start Command  | echo 'Hello John!'  |
| ${stdout}=     | Read Command Output |
| Should Contain | ${stdout}           | Hello John! |

Arguments `return_stdout`, `return_stderr` and `return_rc` are used
to specify, what is returned by this keyword.
If several arguments evaluate to true, multiple values are returned.
Non-empty strings, except `false` and `False`, evaluate to true.

If errors are needed as well, set the argument value to true:
| Start Command   | echo 'Hello John!' |
| ${stdout}       | ${stderr}=         | Read Command Output | return_stderr=True |
| Should Be Empty | ${stderr}          |

Often checking the return code is enough:
| Start Command               | echo 'Hello John!'  |
| ${rc}=                      | Read Command Output | return_stdout=False | return_rc=True |
| Should Be Equal As Integers | ${rc}               | 0                   | # succeeded    |

Using `Start Command` and `Read Command Output` follows
'last in, first out' (LIFO) policy, meaning that `Read Command Output`
operates on the most recent started command, after which that command
is discarded and its output cannot be read again.

If several commands have been started, the output of the last started
command is returned. After that, a subsequent call will return the
output of the new last (originally the second last) command:
| Start Command  | echo 'HELLO'        |
| Start Command  | echo 'SECOND'       |
| ${stdout}=     | Read Command Output |
| Should Contain | ${stdout}           | 'SECOND' |
| ${stdout}=     | Read Command Output |
| Should Contain | ${stdout}           | 'HELLO'  |

This keyword logs the read command with log level `INFO`.</doc>
<tags>
</tags>
</kw>
<kw name="Read Until">
<arguments>
<arg>expected</arg>
<arg>loglevel=None</arg>
</arguments>
<doc>Consumes and returns the server output until `expected` is encountered.

Text up until and including the `expected` will be returned.

If [#Default timeout|the timeout] expires before the match is found,
this keyword fails.

The read output is logged. `loglevel` can be used to override
the [#Default loglevel|default log level].

Example:
| Open Connection | my.server.com |
| Login           | johndoe       | ${PASSWORD}                  |
| Write           | sudo su -     |                              |
| ${output}=      | Read Until    | :                            |
| Should Contain  | ${output}     | [sudo] password for johndoe: |
| Write           | ${PASSWORD}   |                              |
| ${output}=      | Read Until    | @                            |
| Should End With | ${output}     | root@                        |

See also `Read Until Prompt` and `Read Until Regexp` keywords. For more
details about reading and writing in general, see `interactive shells`
section.</doc>
<tags>
</tags>
</kw>
<kw name="Read Until Prompt">
<arguments>
<arg>loglevel=None</arg>
</arguments>
<doc>Consumes and returns the server output until the prompt is found.

Text up and until prompt is returned. [#Default prompt|The prompt must
be set] before this keyword is used.

If [#Default timeout|the timeout] expires before the match is found,
this keyword fails.

This keyword is useful for reading output of a single command when
output of previous command has been read and that command does not
produce prompt characters in its output.

The read output is logged. `loglevel` can be used to override
the [#Default loglevel|default log level].

Example:
| Open Connection          | my.server.com     | prompt=$         |
| Login                    | johndoe           | ${PASSWORD}      |
| Write                    | sudo su -         |                  |
| Write                    | ${PASSWORD}       |                  |
| Set Client Configuration | prompt=#          | # For root, the prompt is # |
| ${output}=               | Read Until Prompt |                  |
| Should End With          | ${output}         | root@myserver:~# |

See also `Read Until` and `Read Until Regexp` keywords. For more
details about reading and writing in general, see `interactive shells`
section.</doc>
<tags>
</tags>
</kw>
<kw name="Read Until Regexp">
<arguments>
<arg>regexp</arg>
<arg>loglevel=None</arg>
</arguments>
<doc>Consumes and returns the server output until a match to `regexp` is found.

`regexp` can be a pattern or a compiled regexp object.

Text up until and including the `regexp` will be returned.

Regular expression check is implemented using the Python
[http://docs.python.org/2/library/re.html|re module]. Python's regular
expression syntax is derived from Perl, and it is thus also very
similar to the syntax used, for example, in Java, Ruby and .NET.

Things to note about the `regexp` syntax:

- Backslash is an escape character in the test data, and possible
  backslashes in the pattern must thus be escaped with another backslash
  (e.g. '\\d\\w+').

- Possible flags altering how the expression is parsed (e.g.
  re.IGNORECASE, re.MULTILINE) can be set by prefixing the pattern with
  the '(?iLmsux)' group (e.g. '(?im)pattern'). The available flags are
  'IGNORECASE': 'i', 'MULTILINE': 'm', 'DOTALL': 's', 'VERBOSE': 'x',
  'UNICODE': 'u', and 'LOCALE': 'L'.

If [#Default timeout|the timeout] expires before the match is found,
this keyword fails.

The read output is logged. `loglevel` can be used to override
the [#Default loglevel|default log level].

Example:
| Open Connection | my.server.com     |
| Login           | johndoe           | ${PASSWORD}                  |
| Write           | sudo su -         |                              |
| ${output}=      | Read Until Regexp | \\[.*\\].*:              |
| Should Contain  | ${output}         | [sudo] password for johndoe: |
| Write           | ${PASSWORD}       |                              |
| ${output}=      | Read Until Regexp | .*@                          |
| Should Contain  | ${output}         | root@                        |

See also `Read Until` and `Read Until Prompt` keywords. For more
details about reading and writing in general, see `interactive shells`
section.</doc>
<tags>
</tags>
</kw>
<kw name="Set Client Configuration">
<arguments>
<arg>timeout=None</arg>
<arg>newline=None</arg>
<arg>prompt=None</arg>
<arg>term_type=None</arg>
<arg>width=None</arg>
<arg>height=None</arg>
<arg>path_separator=None</arg>
<arg>encoding=None</arg>
</arguments>
<doc>Update the `configuration` of the current connection.

Only parameters whose value is other than `None` are updated.

In the following example, [#Default prompt|`prompt`] is set for
the current connection. Other settings are left intact:
| Open Connection          | my.server.com      |
| Set Client Configuration | prompt=$           |
| ${myserver}=             | Get Connection     |
| Should Be Equal          | ${myserver.prompt} | $ |

Using keyword does not affect the other connections:
| Open Connection          | linux.server.com   |                 |
| Set Client Configuration | prompt=$           |                 | # Only linux.server.com affected   |
| Open Connection          | windows.server.com |                 |
| Set Client Configuration | prompt=&gt;           |                 | # Only windows.server.com affected |
| ${linux}                 | ${windows}=        | Get Connections |
| Should Be Equal          | ${linux.prompt}    | $               |
| Should Be Equal          | ${windows.prompt}  | &gt;               |

Multiple settings are possible. This example updates [#Default terminal
settings|the terminal settings] of the current connection:
| Open Connection          | 192.168.1.1    |
| Set Client Configuration | term_type=ansi | width=40 |

Arguments [#Default path separator|`path_separator`] and
[#Default encoding|`encoding`]
were added in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Set Default Configuration">
<arguments>
<arg>timeout=None</arg>
<arg>newline=None</arg>
<arg>prompt=None</arg>
<arg>loglevel=None</arg>
<arg>term_type=None</arg>
<arg>width=None</arg>
<arg>height=None</arg>
<arg>path_separator=None</arg>
<arg>encoding=None</arg>
</arguments>
<doc>Update the default `configuration`.

Please note that using this keyword does not affect the already
open connections. Use `Set Client Configuration` to configure the
active connection.

Only parameters whose value is other than `None` are updated.

This example sets [#Default prompt|`prompt`] to `$`:
| Set Default Configuration | prompt=$ |

This example sets [#Default newline|`newline`] and [#Default path
separator| `path_separator`] to the ones known by Windows:
| Set Default Configuration | newline=CRLF | path_separator=\\ |

Sometimes you might want to use longer [#Default timeout|`timeout`]
for all the subsequent connections without affecting the existing ones:
| Set Default Configuration   | timeout=5 seconds  |
| Open Connection             | local.server.com   |
| Set Default Configuration   | timeout=20 seconds |
| Open Connection             | emea.server.com    |
| Open Connection             | apac.server.com    |
| ${local}                    | ${emea}            | ${apac}= | Get Connections |
| Should Be Equal As Integers | ${local.timeout}   | 5        |
| Should Be Equal As Integers | ${emea.timeout}    | 20       |
| Should Be Equal As Integers | ${apac.timeout}    | 20       |

Arguments [#Default terminal settings|`term_type`],
[#Default terminal settings|`width`],
[#Default terminal settings|`height`],
[#Default path separator|`path_separator`] and
[#Default encoding|`encoding`]
were added in SSHLibrary 2.0.</doc>
<tags>
</tags>
</kw>
<kw name="Start Command">
<arguments>
<arg>command</arg>
</arguments>
<doc>Starts execution of the `command` on the remote machine and returns immediately.

This keyword returns nothing and does not wait for the `command`
execution to be finished. If waiting for the output is required,
use `Execute Command` instead.

This keyword does not return any output generated by the started
`command`. Use `Read Command Output` to read the output:
| Start Command   | echo 'Hello John!'  |
| ${stdout}=      | Read Command Output |
| Should Contain  | ${stdout}           | Hello John! |

The `command` is always executed in a new shell, similarly as with
`Execute Command`. Thus possible changes to the environment
(e.g. changing working directory) are not visible to the later keywords:
| Start Command   | pwd                 |
| ${pwd}=         | Read Command Output |
| Should Be Equal | ${pwd}              | /home/johndoe |
| Start Command   | cd /tmp             |
| Start Command   | pwd                 |
| ${pwd}=         | Read Command Output |
| Should Be Equal | ${pwd}              | /home/johndoe |

`Write` and `Read` can be used for
[#Interactive shells|running multiple commands in the same shell].

This keyword logs the started command with log level `INFO`.</doc>
<tags>
</tags>
</kw>
<kw name="Switch Connection">
<arguments>
<arg>index_or_alias</arg>
</arguments>
<doc>Switches the active connection by index or alias.

`index_or_alias` is either connection index (an integer) or alias
(a string). Index is got as the return value of `Open Connection`.
Alternatively, both index and alias can queried as attributes
of the object returned by `Get Connection`.

This keyword returns the index of the previous active connection,
which can be used to switch back to that connection later.

Example:
| ${myserver}=      | Open Connection | my.server.com |
| Login             | johndoe         | secretpasswd  |
| Open Connection   | build.local.net | alias=Build   |
| Login             | jenkins         | jenkins       |
| Switch Connection | ${myserver}     |               | # Switch using index          |
| ${username}=      | Execute Command | whoami        | # Executed on my.server.com   |
| Should Be Equal   | ${username}     | johndoe       |
| Switch Connection | Build           |               | # Switch using alias          |
| ${username}=      | Execute Command | whoami        | # Executed on build.local.net |
| Should Be Equal   | ${username}     | jenkins       |</doc>
<tags>
</tags>
</kw>
<kw name="Write">
<arguments>
<arg>text</arg>
<arg>loglevel=None</arg>
</arguments>
<doc>Writes the given `text` on the remote machine and appends a newline.

Appended [#Default newline|newline] can be configured.

This keyword returns and [#Interactive shells|consumes] the written
`text` (including the appended newline) from the server output.

The written `text` is logged. `loglevel` can be used to override
the [#Default loglevel|default log level].

Example:
| ${written}=        | Write         | su                         |
| Should Contain     | ${written}    | su                         | # Returns the consumed output  |
| ${output}=         | Read          |
| Should Not Contain | ${output}     | ${written}                 | # Was consumed from the output |
| Should Contain     | ${output}     | Password:                  |
| Write              | invalidpasswd |
| ${output}=         | Read          |
| Should Contain     | ${output}     | su: Authentication failure |

See also `Write Bare`.</doc>
<tags>
</tags>
</kw>
<kw name="Write Bare">
<arguments>
<arg>text</arg>
</arguments>
<doc>Writes the given `text` on the remote machine without appending a newline.

Unlike `Write`, this keyword returns and [#Interactive shells|consumes]
nothing.

Example:
| Write Bare     | su\n            |
| ${output}=     | Read             |
| Should Contain | ${output}        | su                         | # Was not consumed from output |
| Should Contain | ${output}        | Password:                  |
| Write Bare     | invalidpasswd\n |
| ${output}=     | Read             |
| Should Contain | ${output}        | su: Authentication failure |

See also `Write`.</doc>
<tags>
</tags>
</kw>
<kw name="Write Until Expected Output">
<arguments>
<arg>text</arg>
<arg>expected</arg>
<arg>timeout</arg>
<arg>retry_interval</arg>
<arg>loglevel=None</arg>
</arguments>
<doc>Writes the given `text` repeatedly until `expected` appears in the server output.

This keyword returns nothing.

`text` is written without appending a newline and is
[#Interactive shells|consumed] from the server output before
`expected` is read.

If `expected` does not appear in output within `timeout`, this keyword
fails. `retry_interval` defines the time before writing `text` again.
Both `timeout` and `retry_interval` must be given in Robot Framework's
time format (e.g. `5`, `1 minute`, `2 min 3 s`, `4.5`).

The written `text` is logged. `loglevel` can be used to override
the [#Default loglevel|default log level].

This example will write `lsof -c python26\n` (list all files
currently opened by python 2.6), until `myscript.py` appears in the
output. The command is written every 0.5 seconds. The keyword fails if
`myscript.py` does not appear in the server output in 5 seconds:
| Write Until Expected Output | lsof -c python26\n | expected=myscript.py | timeout=5s | retry_interval=0.5s |</doc>
<tags>
</tags>
</kw>
</keywordspec>
